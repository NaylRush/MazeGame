# Игра “Лабиринт”
Тут вам предстоит реализовать консольную версию игры на бумаге “Лабиринт”. Суть игры такова: есть некое поле со стенами, ловушками и выходом, которое известно только ведущему. Остальные игроки в тайне друг от друга указывают ему координаты стартовой локации. Дальше они начинают по очереди ходить по лабиринту, а ведущий сообщает им, уперлись они в стену или смогли пройти. Таким образом, игроки исследуют карту, внимательно озираясь по сторонам, думая, где же расположены ловушки, и пытаясь добраться до выхода раньше соперников. Это продолжается до тех пор, пока какой-нибудь игрок не наткнется на выход и в этом случае он победил!
## Какие есть клетки:
- Оглушение. Игрок, пришедший на эту клетку, пропускает следующие несколько шагов. Его извещают о том, куда он попал, и сколько ходов пропустит.
- Резиновая комната. Игрок может выйти из этой клетки только в одном заданном, известном только ведущему, направлении. Если он попытается пойти в другую сторону, то просто останется на месте, а ведущий нагло ему соврет, что он успешно продвинулся.
- Телепорт. Игрок, пришедший на эту клетку, переносится на клетку с заданными, известными только ведущему, координатами. Игроку сообщается, что его телепортировало, но не сообщается куда.
- Оружейная. Если у игрока, пришедшего на эту клетку, меньше трех патронов (на старте игры их ни у кого нет), то число патронов в его инвентаре становится равно трем. Теперь он может стрелять в заданном направлении. Если он падает в другого игрока, тот погибает, его инвентарь становится пустым, он отправляется на свою стартовую точку и пропускает свой следующий ход.
- Выход. Если игрок двигается из этой клетки в заданном направлении, он выигрывает. И ему об этом даже сообщается.
## Формат решения:
Программа должна вызываться из консоли в двух режимах: проверка карты и игра. В первом режиме она принимает на вход файл с полем и проверяет, что из любой клетки можно добраться до выхода. Сделать это можно с помощью обхода в ширину или глубину. Карта при этом полностью известна, то есть, после попадания в телепорт, вы знаете на каких координатах оказались. Если проверка прошла успешно, нужно вывести на экран “OK”, если нет, выводим “FAILED” и координаты точки, из которой нельзя добраться до выхода.

Пример запуска: ```python3 main.py check --field <path_1>```

В режиме игры запускается игра в интерактивном режиме, то есть игроки будут вводить команды в консоли, а им туда же будут выводиться ответы “ведущего”. В качестве аргумента программа принимает файл с полем, число игроков и стартовые позиции. Последние можно передать явно, а можно через файл, чтобы игроки не могли подсмотреть их друг друга. Число игроков и стартовые позиции - опциональные аргументы. Если они не указаны, программа запрашивает эти данные при старте игры, разумеется, сначала сообщив размер поля. Когда стартовые позиции заданы, игроки начинают по очереди ходить. В свой ход игрок может ввести такие команды:
- в/н/п/л - сходить вверх, вниз, вправо, влево. Для удобства можно сделать возможность вводить направления по-разному, например вверх, up, и т.п.
- патрон <направление> - выстрел в указанном направлении. На это тратится ход. Если у игрока нет патронов, сообщить ему об этом вместо выстрела.
- инвентарь - узнать, что лежит в инвентаре, в базовом варианте - сколько у игрока патронов. На это не тратится ход
- помощь - посмотреть список доступных команд с описанием. На это, разумеется, тоже не тратится ход
Когда один из игроков находит выход, пишем, что он победитель, и завершаемся.

В README.md нужно привести пример команд для запуска вашего кода в каждом из режимов.

## Формат описания поля:
```Давайте сразу на примере.
3 3
.|S E
. . _
S . L
. . .
A R .
E Exit(UP)
S Stun(2)
A Armory()
R RubberRoom(RIGHT)
L RubberRoom(LEFT)
```

В первой строчке указываем размер поля, в данном случае 3 на 3. Дальше идет описание поля. На нечетных линиях описаны клетки и вертикальные стены, на четных линиях - горизонтальные стены. На нечетной линии нечетные символы задают клетки: “.” означает, что это обычная пустая клетка, а буква - означает особую клетку, значение которой описано ниже. Четные символы нечетной линии задают вертикальные стены: пробел означает отсутствие стены, а “|” означает, что стена есть. На четной линии четный символы ничего не задают, а нечетные задают горизонтальные стены: пробел означает отсутствие стены, а “_” означает, что стена есть. В данном примере, стена есть между левым верхним углом (координаты 0,0) и соседней справа клеткой (0, 1) и между правым верхним углом (0, 2) и соседней снизу клеткой (1, 2).

Затем, идет описание особых клеток, каждая буква описывается на отдельной строчке. В этих строчках идет буква, а дальше вызов класса особой клетки с необходимыми ему аргументами. В нашем примере мы одну из клеток (0, 2) сделали выходом, причем чтобы выйти нужно пойти наверх, другие две сделали оглушением на два хода ((0, 1) и (1, 0)) и так далее. Заметьте, что одна буква в поле может использоваться несколько раз.
Классы в вашей программе могут называться по-другому и иметь другие аргументы, если вам так удобней, это просто пример.
## Технические детали:
Чтобы парсить аргументы командной строки, рекомендуется использовать библиотеку argparse.
В поле часть карты задается с помощью кусочков кода, а именно задание особых клеток. В питоне код, помещенный в строку, можно запустить с помощью встроенной функции eval. Имейте в виду, что в “дикой природе” использовать эту функцию нужно с осторожностью. Если строка, которую вы хотите выполнить с помощью eval, приходит от внешнего пользователя, он туда может положить код, который делает что-то плохое. К этой задаче это не относится, jfyi.
Нестандартные библиотеки использовать нельзя.
## Бонусы:
- 0.4 балла. На карту добавляется ключ. Теперь чтобы выйти, нужно сначала найти и подобрать ключ, а лишь потом направиться к выходу. А что делать другим игрокам, когда один из них уже подобрал ключ? Конечно же пристрелить счастливчика! Если игрок погибает, его инвентарь остается лежать на той клетке, где его настигла пуля.
- 0.6 балла. Новая клетка - сон. Когда игрок переходит на неё,  он “засыпает” и переносится на другое поле. Разумеется, ему об этом не сообщают. Следующие несколько ходов он, ничего не подозревая, будет бродить по другому полю. Там тоже могут быть стены, ловушки, там можно найти ключ, можно умереть, ведь другие игроки заснув попадают на ту же карту, или даже выиграть! Но чтобы с вами не случилось, когда вы проснетесь, по истечению времени или из-за смерти или победы во сне, ваш инвентарь вернется к состоянию, в котором он был до сна, и вы вновь окажетесь на исходной карте, в той точке, где уснули. Ведущий сообщает, что игрок проснулся и что находится у него в инвентаре на самом деле, но не говорит, сколько ходов игрок проспал и где он находится. Пока игрок спит, его настоящее тело продолжает стоять на месте. Это значит, что во время сна игрока могут застрелить и наяву. Иными словами, по сну на самом деле ходит не сам игрок, а его “дух”. Теперь, как задать карту для сна? Это делается следующим образом:
    ```
    2
    2 2
    . E
    Z .
    1 1
    .
    E Exit(1)
    Z Sleep(2, (1, 0, 0))
    ```
    В первой строчке задаётся число полей, дальше размер первого (нулевого вернее), затем его описание, а потом размер следующего поля и так далее. Координаты становятся трехмерными, первый индекс - индекс поля. Стартовые позиции игроков по-прежнему двумерные, они начинают на поле с нулевым индексом. В данном примере клетка сна на два хода переносит “дух” игрока на поле с индексом 1 в точку с координатами (0, 0). Обратите внимание, что внутри сна может быть другой сон! Единственное ограничение - между разными полями не должно быть циклов, в частности из сна не должно быть переходов обратно на “настоящее” поле.
- 1 балл. Еще один режим работы: случайная генерация карты. На вход принимаем размер карты, файл, куда нужно записать созданное поле, и опционально random seed для возможности воспроизвести результат. В лабиринте должны с какой-то вероятностью появляться особые клетки разных типов. Алгоритм можете выбрать какой хотите, главное чтобы в итоге из любой точки можно было дойти до выхода. Вот несколько источников, где можно почитать про методы генерации обычных лабиринтов:
https://en.wikipedia.org/wiki/Maze_generation_algorithm
http://www.astrolog.org/labyrnth/algrithm.htm
https://habr.com/ru/post/262345/
https://habr.com/ru/post/176671/
https://habr.com/ru/post/319532/
